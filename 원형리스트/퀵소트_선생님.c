#include <stdio.h>
void quicksort(int*, int, int);//퀵소트 함수 매개변수 선언
//왼쪽파티션은 피벗값보다 큰 값이 논리지시자에서 체크되고, 오른쪽 파티션은 피벗값보다 작은 값이 논리지시자에서 체크된다.
//그리고 잡힌 둘의 위치를 스왑한다.
//피벗을 기준으로 왼쪽 파티션에는 피벗보다 작은 값이, 그리고 오른쪽 파티션에는 피벗보다 큰 값이 모인다.
//재귀로 리스트를 새로 생성할 때, 각각 2개의 배열요소끼리 경쟁시킨다.
//나눠진 모든 하위 리스트를 다시 논리적으로 결합하면 완벽하게 오름차순으로 정렬된 배열이 등장하게 된다.
int main() {
	int ary[] = { 3,5,2,4,7,6,1,8 };
	int size = sizeof(ary) / sizeof(ary[0]);
	printf("ary [] : 3, 5, 2, 4, 7, 6, 1, 8 \n\n");
	quicksort(ary, 0, size - 1);//ary 배열을 이용할 것이고, 첫번째 인덱스부터 마지막 인덱스까지 실인수로 사용할 것이다.
	return 0;
}
void quicksort(int* pary, int left, int right) {//1차원 배열이기 때문에
	int lidx = left, ridx = right;//왼쪽 인덱스는 가장 왼쪽의 인덱스명, 오른쪽 은 가장 오른쪽의 인덱스명.
	int temp;//템프값
	int pivot = (left + right) / 2;//기준(pivot)은 가장 최근에 생성된 리스트의 중간이 될 것이다.
	printf("pivot - index : %d, value : %d\n", pivot, pary[pivot]);
	while (lidx <= ridx) {//왼쪽 논리지시자와 오른쪽 논리지시자가 교차되면 반복문을 탈출하여 재귀함수의 영역을 핸들링 할 것이다.
		//왼쪽 리스트
		while (pary[lidx] < pary[pivot])lidx++;//논리지시자가 오른쪽으로 향하는 것이다. 배열요소끼리 경쟁시킬 때, 파티션의 배열요소보다 큰 값이 나오면 반복문을 탈출한다.
		while (pary[ridx] > pary[pivot])ridx--;//논리지시자가 왼쪽으로 향하는 것이다. 배열요소끼리 경쟁시킬 때, 파티션의 배열요소보다 작은 값이 나오면 반복문을 탈출한다.
		if (lidx <= ridx) {//왼쪽 논리 지시자와 오른쪽 논리지시자를 넘어서게 되면 아래 하의 연산을 시행 시킬 것이다.
			temp = pary[ridx];//오른쪽 논리지시자의 배열요소값을 템프값에 저장한다.
			pary[ridx] = pary[lidx];//오른쪽 논리지시자의 배열요소에 왼쪽 논리지시자의 배열요소를 할당한다.
			pary[lidx] = temp;//왼쪽 논리지시자의 배열요소에 오른쪽 논리지시자의 배열요소를 할당한다.
			printf("%d : %d\n", temp, pary[ridx]);//스왑됨
			lidx++;//새로 생성된 우측 파티션에서 자기자신과 경쟁시킬 필요는 없으니 초기 논리 지시자를 우측으로 한칸 넘겨준다.
			ridx--;//새로 생성된 좌측 파티션에서 자기자신과 경쟁시킬 필요는 없으니 초기 논리 지시자를 좌측으로 한칸 넘겨준다.
		}
	}
	for (int i = 0; i <= right; i++)printf("%3d", pary[i]);//파티션 값들을 출력해서 제대로 넘어갔는 지 확인해본다.
	printf("\n");//개행한다.
	if (left < ridx)quicksort(pary, left, ridx);//재귀파트이다. 좌측 파티션에 대해서 논리적으로 파티션을 재귀적으로 다룰 것이다.
	if (lidx < right)quicksort(pary, lidx, right);//재귀파트이다. 우측 파티션에 대해서 논리적으로 파티션을 재귀적으로 다룰 것이다.
	//해당 조건에 의해 모든 배열요소들이 재귀적으로 하나씩 논리적 리스트가 만들고 서로 경쟁해서 낮은 값이 좌측으로 쏠리게 되고
	//최종적으로 해당 조건을 만족시키지 않으면, 물리적으로 반환값에 의해, 논리적으로 분할된 리스트들을 하나로 결합된 형태에 의해 최종적으로 오름차순으로 정정된 리스트 값이 순차적으로 나열되게 된다.
}