# Data_structure_learned_by_C
Study
<br>
![혼공C](https://book.naver.com/bookdb/book_detail.nhn?bid=15028694)<br>
<img src="https://github.com/ochestra365/StudyAspNet21/blob/main/BasicMVCModel2/MyPortpolioWeb/wwwroot/assets/img/faces/%ED%98%BC%EA%B3%B5C.jpg" width="100%" height="100%" ><br><br>
--------------

## 목차 <br>
1. c언어에 대한 개념적 접근<br>
2. 버퍼<br>
3. 메모리<br>
4. 접근<br>
5. 코드 파일 정리<br>
6. 깨알 용어 정리<br>
------------------
## 1. c언어에 대한 개념적 접근
<br>
C언어란 절차지향 프로그래밍 언어이다. 따라서 코딩의 순서대로 프로그램의 실행 순서를 제어할 수 있다.<br>
이러한 특성을 이용하여 다양한 알고리즘의 구현방법으로 사용된다.<br>
또한 메모리를 상당히 많이 다루는 데, 직접적인 컴퓨터 하드웨어를 제어하는 기능에 특화되어 있다고 볼 수 있다.<br>
기존의 객체지향프로그래밍이 현실 세계를 객체화하여 비즈니스 편의성을 구한다면, C언어는 비즈니스 로직 그 자체를 직접적으로 다룬다고 볼 수 있다.<br>
특히 구현을 잘 하기 위해서는 정수형, 문자형, 포인터 활용, 배열 활용, 포인터 배열 및 배열포인터 활용에 대한 입_출력 함수를 구현하는 것이 가장 기초라고 볼 수 있다.<

--------------
## 2. 버퍼
<br>
가장 중요한 개념이 버퍼이다.<br>
버퍼란 운영체제에서 자동으로 할당한 임시저장 메모리를 의미한다.<br>이 메모리에 사용자가 각 데이터를 할당하면 컴파일러를 통해 데이터 타입의 각 비트 단위를 코드로 enconding한다.<br>
또한 encoding한 각 비트 단위를 decoding하여 필요한 아스키 코드나 데이터 타입의 상수 주소값으로 포인터한다.<br>


## 3. 메모리
----------------
-----------
메모리라는 개념이 가장 중요하다. 변수나 포인터, 배열을 통해서 사용자가 필요한 데이터들을 메모리에 저장하고, 그것들을 Logic을 통해서 연산한 결과 값을 Return하는 것이 주 형식이다.<br>
프로그램에 필요로 하는 주된 메모리는 RAM이며, 필요한 경우 CPU와 가장 가깝고 연산이 빠른 레지스터 메모리도 사용한다. <br>이때, 필요한 변수에 예약어는 Reister이다.<br>
연산은 CPU의 ALU에서 각 변수의 값을 로드해서 스토어란 과정을 통해 Return 값으로 메모리에 돌려준다.<br>
메모리는 크게 Code Segment와 Data Segment로 양분된다. Code Segment에는 코드가 적재되고, Datasegment에는 Stack,Heap,정적 메모리가 할당된다.<br>
Stack은 휘발성이 강한 메모리 영역으로 지역변수같은 연산이 한번 종료되면 사라지는 파트들이 적재된다.<br>
다음으로 Heap은 동적할당을 위한 Data를 위해 사용자가 직접 메모리를 할당하여 사용하는 것이다.<br>마지막으로 정적 메모리는 OS가 자동으로 할당한 메모리를 의미하며 프로그램이 종료될 때까지 할당되어
<br>사용된다.

## 4. 접근
----------------
변수에 값을 할당한다. 그리고 변수가 저장된 상수 주소에 접근하여 간접적으로 값에 영향을 준다. 즉, 값을 저장하는 변수와 주소값을 다루는 포인터가 기초 공리가 되어 확장된 개념성을 가지는 것이<br>
C언어의 특징이다. 사실 이 2가지 개념으로 발견에 발견을 거듭하여 정형화 된 것이 C언이이기 때문에 이거 2개만 잘 알고 있어도 외울 것이 없다.<br> 당연하게 받아들이는 것이다.<br> 그저 생각의 흐름을
빨리 하기만 하면 이전 프로그래머가 생각한 것들을 다수 따라잡을 수 있다.
## 5. 코드 파일 정리
----------------
![Chapter1](https://github.com/ochestra365/StudyAspNet21/tree/main/BasicMVCModel2/MyPortpolioWeb/Models "Model")<br>
![Chapter2](https://github.com/ochestra365/StudyAspNet21/tree/main/BasicMVCModel2/MyPortpolioWeb/Views "View")<br>
![Chapter3](https://github.com/ochestra365/StudyAspNet21/tree/main/BasicMVCModel2/MyPortpolioWeb/Controllers "데이터 읽기 및 저장 생성")<br>
![Chapter4](https://github.com/ochestra365/StudyAspNet21/tree/main/BasicMVCModel2/MyPortpolioWeb/wwwroot "MainApp 구동")<br>

## 6. 깨알 용어 정리
----------------
+ 기억부류(storage class) : 변수를 사용 범위와 메모리에서의 존재 기간에 따라 나눈 것이다. 따라서 지역변수는 변수의 특성 중에 사용 범위를 강조한 것이다.
+ stdio.h(standard input&output added to headerfile)
+ 소스파일(source file) : 프로그래밍 언어의 문법에 맞게 작성한 문서 파일.
+ 소스코드(source code) : 프로그래밍 언어의 문법에 맞게 작성한 글.
+ 컴파일(compile) : 소스 파일을 컴퓨터가 이해하는 기계어로 바꾸는 과정(전처리->컴파일->링크)--(Source.c->전처리된 소스 파일-> 개체파일(added startup code)->실행 파일)
+ Call by Value : 원본 데이터를 보존할 수 있으므로 안정성을 담보해야 하는 상황에 사용한다.
+ Call by reference : 호출 함수의 변수를 피호출 함수에서 매개변수의 이름으로 직접 사용하는 방식이다. 따라서 C언어는 Call by value 밖에 없다.
+ 메모리 누수(memory leak) :  컴퓨터 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상이다. 할당된 메모리를 사용한 다음 반환하지 않는 것이 누적되면 메모리가 낭비된다. 즉, 더 이상 불필요한 메모리가 해제되지 않으면서 메모리 할당을 잘못 관리할 때 발생한다.[1] 일부 서적에서 메모리 손실이라는 용어로 뜻을 옮기기도 하지만[2] leak라는 표현은 단순히 잃는 것 이상의 개념이므로 누수라는 표현이 더 정확하다.
+ 디버깅(debugging) : 에러를 수정하는 것.
+ main 함수(main function) : 코드 실행이 제일 처음 시작되고, 제일 마지막으로 끝나는 곳. 줄여서 'main' 또는 '메인'이라고도 한다.
+ 변환 문자 : 출력 시 데이터의 형태에 따라 변숫값을 텍스트로 바꾸어주거나, 입력 시 텍스트를 알맞은 변숫값으로 바꾸어주는 문자.
+ 정규화(nomalization) : 소수점 앞에 0이 아닌 한 자리만을 사용해서 지수 형태로 바꾸어 주는 것.
+ 아스키코드(ASCII code) : 사람이 사용하는 기호를 컴퓨터 안에서 표현하는 방법에 대해 약속한 것.
+ 주석문(comment) : 실행 결과에 영향을 미치지 않는 문장. 소스 코드를 설명하는 내용을 담게 된다.
+ pritnf 함수 화면에 데이터를 출력하는 함수. print foramtted의 약어. 변환 문자를 사용해서 변수에 맞는 자료형을 알려준다.
+ 제어 문자(control character) : 문자는 아니지만, 출력 방식에 영향을 주는 문자.
+ 상수(constant) : 값을 한 번 정하면 프로그램이 끝날 때까지 변하지 않는 함수. 원주율 값처럼 값이 정해져 있고, 변하면 안되는 경우에 주로 사용한다.
+ 비트(bit) : 컴퓨터 저장장치의 가장 작은 단위. 스위치와 같이 두 가지 상태를 나타낸 것.
+ 바이트(byte) : 컴퓨터 저장장치의 단위. 1바이트는 8비트, 16진수를 사용하는 이유는 4비트 단위로 이진수 값을 표현하기 위해서 이다.
+ 변수(variable) : 데이터를 저장하는 메모리의 공간.
+ 변수 선언 : 어떤 형태와 이름을 가지고 사용한다고 알리는 것.
+ 할당 : 변수에 값을 넣거나 저장하는 것을 '할당한다'고 한다.
+ 참조 : 변수에 접근하는 것을 '참조한다'고 한다.
+ 쓰레기 값(garbage) : 변수로 지정했던 공간에는 다른 프로그램이 사용한 흔적이 남아 있을 수 있는데, 남아 있는 이 값이 쓰레기 값이다.
+ 초기화(initialize) : 변수, 배열, 구조체에 처음으로 값을 대입하는 것.
+ 자료형(data type) : 자료의 형태. 자료형에 따라 컴퓨터가 어떻게 처리하는지 달라진다.
+ 헤더 파일(header file) : 표준 라이브러리 함수의 원형 등을 포함하고 있는 파일. 줄여서 '헤더'라고도 한다. 라이브러리는 쉽게 가져다 쓰라고 미리 구현해둔 함수. <br>#include라는 전처리 지시자로 불러들인다.
+ const 변수 : 한 번 초기화하면 값을 바꿀 수 없는 변수. 값이 항상 고정되어 코드가 실행되는 동안은 바꿀 필요가 없을 때 사용한다.
+ 식별자(identifier) : 필요에 따라 사용자가 만들어 쓰는 단어. 보통 함수나 변수의 용도에 맞게 의미 있는 이름을 사용한다.
+ 예약어(reserved word) : 언어에 의해 예약된 단어로, 식별자로 사용할 수 없는 단어이다.
+ 2의 보수(2's complement) : 절대값의 이진수를 0과 1로 반전시킨 상태에서 1을 더한 값
+ 연산자(operator) : 연산에 사용되는 표시나 기호
+ 피연산자(operand) : 연산의 대상이 되는 데이터
+ 전위표기(prefix) : 연산자가 피연산자 앞에 놓이는 수식 표기
+ 후위표기(postfix) : 연산자가 피연산자 뒤에 놓이는 수식 표기
+ 형 변환 : 자료형을 다른 자료형으로 변환하는 것.(암시적 형변환{promotion : 자료형이 일치하지 않는 값이 들어왔을 때, 변환이 가능한 타입에 한하여 알맞은 자료형으로 컴파일러가 바꿔주는 것.}과 강제 형변환{casting : 일시적으로 값을 원하는 형태로 바꾸는 것}이 있다.)
+ 배타적 논리합(exclusive or) : 두 피연산자의 진리값이 서로 다를 때만 참이 되는 연산
+ 숏 서킷 룰(short circuit rule) : 좌항으로 &&dhk || 연산 결과를 판별하는 기능.
+ ALU(Arithmetic Logic Unit) : CPU의 산술논리 연산장치
+ 레지스터(register) : CPU의 메모리. 연산할 데이터와 연산 후의 결과를 임시로 저장한다.
+ 로드(load) : 메인 메모리에서 레지스터로 값을 복사하는 과정
+ 스토어(store) : 연산이 완료된 값을 레지스터에서 메인 메모리로 복사하는 과정.
+ 제어문 : 특정 조건에 따라 실행하거나 실행하지 않아야 할 때 사용하는 문장.
+ 블록(block) : 함수, 반복문, 선택문 등의 중괄호로 이루어진 단위를 말한다.
+ 조건문(conditional statement) : 특정 조건을 만족할 때 실행하는 문법.
+ 매달린 else 문제(Dangling else Problem) : if문을 중첩해서 사용할 때, 뒤따르는 else의 위치가 모호해지면서 생기는 문제.
+ loop : 특정 조건을 만족하는 동안 반복해서 실행하는 문법
+ 무한 반복문 : 무한히 반복을 하고 싶거나 정해진 횟수 없이 일정한 조건을 충족하면 빠져나오게 하고 싶을 때 사용, 무한 루프라고도 한다.
+ continue문 : continue문 아래의 코드를 실행하지 않고 반복문의 조건을 검사한 후 다시 루프문을 시작하게 하는 예약어
+ 함수 (function) : 기능을 수행하는 코드 단위
+ 함수 정의 : 함수를 실제 코드로 만드는 것.
+ 함수 호출 : 함수를 필요한 곳에서 사용하는 것.
+ 함수 선언 : 프로그램의 상단에서 어떤 함수를 만들어서 쓸 것이라고 컴파일러에게 정보를 주는 것.
+ 함수 원형 : 함수명, 매개변수, 반환형을 적은 것.
+ 재귀호출 함수 : 함수 안에서 자신을 호출하는 함수
+ 매개변수(parameter) : 함수가 처리할 데이터를 저장하는 변수.
+ 배열(array) : 기본 자료형을 여러 개 묶어서 사용하는 것. 인덱스를 가지고 순차적으로 순회하며 변수에 접근할 수 있다. 
+ 배열 선언 : 어떤 이름을 가지고 어떤 형태의 변수가 몇 개인지를 컴파일러에 알리는 것.
+ 첨자(index) : 배열에서 순차적으로 나열된 요소에 매겨진 번호. 요소에 접근할 때 사용한다. 영문명 그대로 인덱스라고 한다.
+ sizeof 연산자 : 변수가 메모리에 할당된 크기를 바이트 단위로 반환하는 함수.
+ 포인터 (pointer) : 주소를 저장하는 변수로 일반 변수와 마찬가지로 선언 후에 사용한다.
+ 간접 참조 연산자 : 포인터가 가리키는 변수를 사용할 때 포인터에 사용하는 특별한 연산자.
+ 주소연산자 : 변수의 주소를 구할 때 사용하는 연산자.
+ 주소연산자 : 포인터에 이 주소값을 저장해서 해당 메모리에 접근할 수 있고, scanf에서 사용할 떄처럼 함수에 메모리 주소를 전달하는 용도로 사용할 수 있다. 비트 연산자와는 다르므로 헷갈리지 말자.
+ 메모리 주소 (address) : 주소, 주소값이라고도 한다. 메모리 상 데이터의 위치를 식별할 수 있는 값. 보통은 해당 데이터의 시작 위치를 주소 값으로 가짐.
+ 주소는 변수에 할당된 메모리  저장 공간의 시작 주소값 그 자체이고, 포인터는 그 값을 저장하는 또 다른 메모리 공간이다. 포인터는 가리키는 자료형과 관계없이 크기가 모두 같다.
+ 배열명 : 배열의 첫 번째 요소의 주소이기 때문에 배열의 첫 번째 요소를 가리킨다. 포인터처럼 사용할 수 있으나, 포인터와 들게 배열명은 상수이고 그 값을 바꿀 수 없다.
+ scanf함수 stdin 스트림 파일로부터 데이터를 형식에 따라 변환하여 입력하는 함수
+ 화이트 스페이스(white space) : space, tab, enter,를 눌렀을 때, 입력되는 문자를 묶어 부르는 말.
+ 버퍼(buffer) : 프로그램이 출력한 데이터를 모아서 한꺼번 출력 장치로 보내거나 입력 장치에서 한 번에 많은 데이터를 읽어 저장해놓고 프로그램이 필요한 데이터를 바로 꺼내 쓸수 있도록 준비하는 공간.
+ gets 함수 : stdin 스트림 파일로부터 한 줄의 데이터를 읽는 함수.(char ^gets(char ^str);)
+ strcpy함수 : 문자열을 복사한다.(char ^strcpy(char ^dest,const char^ src);)
+ 지역변수(local varialbe)==자동변수 : 블록 내에 선언되어 해당 블록 내에서만 사용할 수 있는 변수. 따라서 다른 블록 내에서는 사용할 수 없다. auto 예약어와 함께 함수 안에서 지역변수를 선언한다. auto가 없어도 블록 안에서 선언된 변수는 자동으로 지역 변수가 된다.
+ 기억 부류(storage class) : 변수를 사용 범위와 메모리에서의 존재 기간에 따라 나눈 것.
+ 전역 변수(global variable) : 함수 밖에 변수를 선언하면 전역 변수가 된다. 전역 변수는 특정 함수의 블록에 포함되지 않으므로 사용 범위가 함수나 블록으로 제한되지 않는다.
+ 정적 지역 변수(static local variable) : 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지하는 변수.
+ 레지스터 변수(register variable) : 블록 혹은 함수 내에 변수를 선언할 때 사용할 수 있는 변수이다. CPU 내의 공간인 레지스터에 저장되기 때문에 일반적인 지역 변수와는 다르다.
